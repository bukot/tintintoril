#CLASS {general} OPEN

#ACTION {Aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa general.tt$}
{
	#nop /* this action can be removed but is used to document the file and   */;
	#nop /* it's functionality.                                               */;
	#nop /* external dependencies...                                          */;
	#nop /*      {classset.tt}                                                */;
	#nop /*           must be present to make use of auto class feature load  */;
	#nop /*           and name assignment                                     */;
	#nop /*                                                                   */;
	#nop /*      {combat.tt}                                                  */;
	#nop /*           needed to make use of common combat features            */;
	#nop /*                                                                   */;
	#nop /*      {espeak unix module}                                         */;
	#nop /*           must be present to make use of text to speech features  */;
	#nop /*                                                                   */;
	#nop /*      {mapping.tt}                                                 */;
	#nop /*           must be present to make use of map features             */;
	#nop /*                                                                   */;
	#nop /*           {mstatic} alias as part of loadmap                      */;
	#nop /*                                                                   */;
	#nop /*      {mapport.tt}                                                 */;
	#nop /*           must be present to make proper use of mapping auto      */;
	#nop /*           locate features                                         */;
	#nop /*                                                                   */;
	#nop /*                                                                   */;
	#nop /* aliases and usage                                                 */;
	#nop /*      {astat <string>}                                             */;
	#nop /*           will send a tell to katumi and get the advanced stats   */;
	#nop /*           for an item (string value)                              */;
	#nop /*                                                                   */;
	#nop /*      {killclass <word>}                                           */;
	#nop /*           shortcut for #class <word> kill                         */;
	#nop /*                                                                   */;
	#nop /*      {load <word>}                                                */;
	#nop /*           shortcut for #read <word>.tt                            */;
	#nop /*                                                                   */;
	#nop /*      {loadmap <string>}                                           */;
	#nop /*           saves and closes currently loaded map then loads the    */;
	#nop /*           specified map and all mapping files, and sets the map   */;
	#nop /*           to static.                                              */;
	#nop /*           if you change this pay attention to the order you do    */;
	#nop /*           things so you don't destroy your map file by accident.  */;
	#nop /*                                                                   */;
	#nop /*      {logon <word>}                                               */;
	#nop /*           creates a session named <word> and connects to the mud  */;
	#nop /*                                                                   */;
	#nop /*      {loot <string>}                                              */;
	#nop /*           get or gget all from <string> if string is ommited it   */;
	#nop /*           loots corpse automatically if only a number it supplied */;
	#nop /*           it loots <string>.corpse automatically                  */;
	#nop /*                                                                   */;
	#nop /*      {loottype <target> <a>}                                      */;
	#nop /*           sets the type of thing to loot <target> the optional    */;
	#nop /*           parameter a is used to denote all.<target> if used      */;
	#nop /*           if omitted it will default to 1.<target>                */;
	#nop /*                                                                   */;
	#nop /*      {resetclass <word>}                                          */;
	#nop /*           kills the class named <word>.tt and reloads it from     */;
	#nop /*           disk.  depends on saveclass from same file              */;
	#nop /*                                                                   */;
	#nop /*      {saveclass <word>}                                           */;
	#nop /*           saves the class named <word>.tt                         */;
	#nop /*                                                                   */;
	#nop /*      {setme <word>}                                               */;
	#nop /*           sets the value of $me to <word> formatted as all lower  */;
	#nop /*           several processes could set the value of this var so    */;
	#nop /*           this makes normalizing it easier                        */;
	#nop /*                                                                   */;
	#nop /*      {stat <word>}                                                */;
	#nop /*           see astat, but uses the abbreviated stat from katumi    */;
	#nop /*                                                                   */;
	#nop /*      {statcall on|off}                                            */;
	#nop /*           will turn the stat caller on or off                     */;
	#nop /*                                                                   */;
	#nop /*      {tloot <on|off|group>}                                       */;
	#nop /*           sets the auto looter mode.  allows for abreviation of   */;
	#nop /*           options and use or not of spaces.                       */;
	#nop /*                                                                   */;
	#nop /*      {oepn}                                                       */;
	#nop /*           replaces it with open.  I make this typo alot           */;
	#nop /*                                                                   */;
	#nop /*      {opne}                                                       */;
	#nop /*           see oepn                                                */;
	#nop /*                                                                   */;
	#nop /*      {speechoff}                                                  */;
	#nop /*           disables the speech processes in case of spam overload  */;
	#nop /*           but allows it to be restarted automatically.            */;
	#nop /*                                                                   */;
	#nop /*                                                                   */;
	#nop /* variables set by class                                            */;
	#nop /*      {caller}                                                     */;
	#nop /*           used to determine if condition caller is active         */;
	#nop /*                                                                   */;
	#nop /*      {class}                                                      */;
	#nop /*           used to store the current loaded character class        */;
	#nop /*                                                                   */;
	#nop /*      {classcheck} used to determine if a score command should be  */;
	#nop /*           sent to the mud so the current class can be auto grabbed*/;
	#nop /*                                                                   */;
	#nop /*      {encond}                                                     */;
	#nop /*           used by stat tracker to store the last enemy condition  */;
	#nop /*                                                                   */;
	#nop /*      {enemy}                                                      */;
	#nop /*           used to track the currently engaged enemy's name when in*/;
	#nop /*           battle                                                  */;
	#nop /*                                                                   */;
	#nop /*      {general}                                                    */;
	#nop /*           used to determine if the general class is loaded        */;
	#nop /*                                                                   */;
	#nop /*      {loot}                                                       */;
	#nop /*           used to determine status of auto looter                 */;
	#nop /*                                                                   */;
	#nop /*      {loott}                                                      */;
	#nop /*           is used to store the desired item to loot.  initializes */;
	#nop /*           to <all> on load.                                       */;
	#nop /*                                                                   */;
	#nop /*      {mapname}                                                    */;
	#nop /*           name of the map file that is loaded, or blank.  it is   */;
	#nop /*           initiated here to allow testing it's value in           */;
	#nop /*           general.tt                                              */;
	#nop /*                                                                   */;
	#nop /*      {speechon}                                                   */;
	#nop /*           used to determine if the speech routine has been called */;
	#nop /*           yet                                                     */
}
{1}

#ACTION {%* briefly reveals a red aura}
{
	gsay %1 is cursed!;
	#showme $me says %1 is cursed!
}
{5}

#ACTION {%* seems to be blinded!}
{
	#nop gsay %1 is blind!;
	#showme $me says %1 is blind!
}
{5}

#ACTION {%* suddenly looks speechless!}
{
	gsay %1 is being weally weally quite (silenced);
	#showme $me says %1 is silenced;
	#class silence kill
}
{5}

#ACTION {%w has just given you %w consent.}
{
	group %1 Let's go get ded!
}
{5}

#ACTION {You have learned something new about %*!}
{
	gsay %1 up!;
	#showme {you say %1 up!}
}
{5}

#ACTION {^Type the # or name of a character above to login or choose an action below.}
{
	#class rogue kill;
	#class cleric kill;
	#class psionicist kill;
	#class warrior kill;
	#variable {classcheck} {1};
	load classset;
	#if {$mapping}
	{
		load mapport
	}
}
{5}

#ACTION {^You raise a level!$}
{
	gsay Level UP!;
	#showme {You say Level UP}
}
{5}

#ACTION {^You receive %* XP (%*) experience.}
{
	#if {&loot}
	{
		#if {$loot}
		{
			loot
		}
	}
}
{5}

#ACTION {{< (\d{1,4})h/(\d{1,4})H(?: \d{1,3}p/\d{1,3}P)? (\d{1,4})v/(\d{1,4})V (.*)>}}
{
	#variable {pextra} {%6};
	#variable enemy {};
	#if {&etarg}
	{
		#class etarg kill
	};
	#regexp {$pextra} {{E:\s*(\w*)}} {#variable {enemy} {&2};};
	#if {"$enemy" != "" && $caller}
	{
		#regexp {$pextra} {{EC: ((?:nasty wounds)|(?:pretty hurt)|(?:awful)) (?:EP:)}} {#if {"&2" != "$encond"}{#var encond {&2};gsay $enemy is at $encond;};}
	};
	#else
	{
		#unvariable {encond}
	};
	#if {$groupcheck}
	{
		#class groupcheck kill;
		#unvariable stattarg;
		statfix
	};
	#if {$stateffects}
	{
		#class kill stateffects
	};
	#class glistadd kill;
	#if {$classcheck}
	{
		#variable classcheck 0;
		score
	};
	#unvariable pextra
}
{5}

#ACTION {~%i{^((?:\x1B\[(?:;?\d{1,3})+(?:m|K))*\w+(?:\x1B\[(?:;?\d{1,3})+(?:m|K))* (?:(?:\x1B\[(?:;?\d{1,3})+(?:m|K))*\(H\)(?:\x1B\[(?:;?\d{1,3})+(?:m|K))* )?(?:\x1B\[(?:;?\d{1,3})+(?:m|K))*(?:says?|tells?|group-says?|OOC|GCC|NHC|LFG|shouts?|(?:(?:group-)?projects? ')|(?:responds to your petition)|(?:responds to your group)).*)}}
{
	#nop /* this line will perform the same match without capturing ansi      */;
	#nop /* substitute the following for everything between {} in the action  */;
	#nop /* line above                                                        */;
	#nop /* %i{^(\w+ (?:\(H\) )?(?:says?|tells?|group-says?|OOC|GCC|NHC|LFG|shouts?|(?:(?:group-)?projects? ')|(?:responds to your petition)|(?:responds to your group)).*)} */;
	#format timestamp {%t} {{%H:%M:%S}};
	#line log chatlog.txt {%0 :: $timestamp};
	#unvariable timestamp;
	#variable {saytxt} {%1};
	#replace {saytxt} {{\x1B.*?[m|K]}}{};
	#replace {saytxt}{'}{};
	#replace {saytxt}{"}{};
	#if {&statuses}
	{
		#variable statorlist {};
		#foreach {$tracked} {i}
		{
			#if {"$statorlist" != ""}
			{
				#variable statorlist {$statorlist|$i}
			};
			#else
			{
				#variable statorlist {$i}
			}
		};
		#foreach {$stats} {thisstat}
		{
			#regexp {$saytxt} {%i{^($statuses) .*(?:$statreg[$thisstat]).*?(?:out|off|expired|down|faded|bu-bye!)}} {statset @btarg{&2} $thisstat out;statfix;}
		};
		#unvariable thisstat
	};
	#nop /* to disable mud reading disable the following lines up to the first #unvariable */;
	#if {$speechon}
	{
		#nop
	};
	#else
	{
		#variable {speechon}{1};
		#run speech espeak;
		#speech #kill;
		#session -
	};
	#regexp {$saytxt} {%i{(katumi tells.*)}} {#NOP;};
	#else
	{
		#speech {$saytxt}
	};
	#nop /* stop disabling here                                                             */;
	#unvariable {saytxt};
	#unvariable statorlist
}
{5}

#ALIAS {%i{astat (.+)}}
{
	tell katumi astat %2
}
{5}

#ALIAS {%i{killclass (\w+)}}
{
	#class %2 kill
}
{5}

#ALIAS {%i{load (\w+)}}
{
	#read %2.tt
}
{5}

#ALIAS {%i{loadmap(?: (\w*))?}}
{
	#if {"%2" != ""}
	{
		#if {"$mapname" != ""}
		{
			#map write $mapname;
			killclass mapping;
			killclass mapport;
			killclass mapmistake;
			killclass trans;
			#map destroy
		};
		#class mapkil open;
		#class mapkil write mapdisp.txt;
		#class mapkil kill;
		load mapping;
		#event {MAP ENTER MAP}{mstatic on;#unevent {MAP ENTER MAP}};
		#variable mapname %2;
		#map read $mapname;
		load mapport;
		load mapmistake;
		#echo {map %2 loaded}
	};
	#else
	{
		echo {no map file was specified map not loaded}
	}
}
{5}

#ALIAS {%i{logon (\w+)}}
{
	#session %2 50.57.109.188 9999
}
{5}

#ALIAS {%i{loot(?: (.*))?$}}
{
	#variable {ltarg} {corpse};
	#showme %2;
	#regexp {%2} {{([0-9]+)}} {#var ltarg &1.corpse};
	#regexp {%2} {%i{([0-9]*[a-zA-Z\.]+)}} {#var ltarg &1};
	#if {$loot == 2}
	{
		gget $loott $ltarg
	};
	#else
	{
		get $loott $ltarg
	};
	#unvariable ltarg
}
{5}

#ALIAS {%i{loottype ([a-z.0-9]+)(?: (a))?}}
{
	#if {"%3" == "a"}
	{
		#variable {loott} {all.%2}
	};
	#else
	{
		#variable {loott} {%2}
	}
}
{5}

#ALIAS {%i{resetclass (\w+)}}
{
	#class %2 kill;
	load %2
}
{5}

#ALIAS {%i{saveclass (\w+)}}
{
	#class %2 write %2.tt
}
{5}

#ALIAS {%i{setme (\w+)}}
{
	#format {me} {%l} {%2}
}
{5}

#ALIAS {%i{stat (.+)}}
{
	tell katumi stat %2
}
{5}

#ALIAS {%i{statcall ?(on|of)?.*}}
{
	#if {"%2" != ""}
	{
		#switch {"%2"}
		{
			#case {"on"}
			{
				#variable {caller} {1}
			};
			#case {"of"}
			{
				#variable {caller} {0}
			}
		};
		statcall
	};
	#else
	{
		#variable callerstat off;
		#if {$caller}
		{
			#variable callerstat on
		};
		#showme {You say stat caller is $callerstat};
		#unvariable callerstat
	}
}
{5}

#ALIAS {%i{tloot ?(of|on|gr)?.*}}
{
	#switch {"%2"}
	{
		#case {"of"}
		{
			#variable loot 0;
			tloot
		};
		#case {"on"}
		{
			#variable loot 1;
			tloot
		};
		#case {"gr"}
		{
			#variable loot 2;
			tloot
		};
		#default
		{
			#switch {$loot}
			{
				#case {1}
				{
					say loot is on
				};
				#case {2}
				{
					say loot is for group (and thats good enough for me)
				};
				#default
				{
					say loot is off
				}
			};
			#showme {you say you are looting $loott};
			#showme {you say use loottype <target> <a :to get all, omit for 1.>};
			#showme {you say use "loottype all" to get all}
		}
	}
}
{5}

#ALIAS {oepn}
{
	open
}
{5}

#ALIAS {opne}
{
	open
}
{5}

#ALIAS {speechoff}
{
	#speech #zap;
	#unvariable speechon
}
{5}

#EVENT {PROGRAM START}
{
	#split
}

#EVENT {SESSION CONNECTED}
{
	load combat;
	load spellout;
	load statwin
}

#EVENT {SESSION DISCONNECTED}
{
	#if {$mapping}
	{
		msave
	}
}

#FUNCTION {btarg}
{
	#if {"%1" != ""}
	{
		#format {btname} {%l} {%1};
		#regexp {"$btname"} {{[1-9]}} {#IF {&t[%1]}{#RETURN $t[%1]};#ELSE {#VAR {result} {self}}};
		#else
		{
			#if {"$btname" == "me"}
			{
				#variable {result} {self}
			};
			#else
			{
				#variable {result} {$btname}
			}
		};
		#unvariable btname
	};
	#else
	{
		#if {&t[1]}
		{
			#variable {result} {$t[1]}
		};
		#else
		{
			#variable {result} {$me}
		}
	}
}

#MACRO {\eOk}
{
	d
}

#MACRO {\eOm}
{
	u
}

#MACRO {\eOr}
{
	s
}

#MACRO {\eOt}
{
	w
}

#MACRO {\eOu}
{
	l
}

#MACRO {\eOv}
{
	e
}

#MACRO {\eOx}
{
	n
}

#TAB              {@delkor}
#TAB              {@gormal}
#TAB              {@iamtux}
#TAB              {@lilithelle}
#TAB              {@lilmeshay}
#TAB              {bukot}
#TAB              {lilabipple}
#TAB              {lilebeple}
#TAB              {lilithelle}
#TAB              {mixxillezissiy}
#TAB              {nilebbeple}
#TAB              {zenpegeble}
#VARIABLE         {caller}  {0}
#VARIABLE         {class}  {}
#VARIABLE         {classcheck}  {0}
#VARIABLE         {enemy}  {}
#VARIABLE         {general}  {1}
#VARIABLE         {loot}  {0}
#VARIABLE         {loott}  {all}
#VARIABLE         {mapname}  {}
#VARIABLE         {race}  {}
#VARIABLE         {speechon}  {0}

#CLASS {general} CLOSE
