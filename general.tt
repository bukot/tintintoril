#CLASS {general} OPEN

#ACTION {Aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaageneral.tt$}
{
	#nop /* this action can be removed but is used to document the file and   */;
	#nop /* it's functionality.                                               */;
	#nop /* dependencies...                                                   */;
	#nop /*      {classset.tt} must be present to make use of auto class      */;
	#nop /*                    feature load and name assignment               */;
	#nop /*                                                                   */;
	#nop /*      {combat.tt} needed to make use of common combat features     */;
	#nop /*                                                                   */;
	#nop /*      {espeak unix modual} must be present to make use of text to  */;
	#nop /*                           speech features                         */;
	#nop /*                                                                   */;
	#nop /*      {mapping.tt} must be present to make use of map features     */;
	#nop /*                                                                   */;
	#nop /*      {mapport.tt} must be present to make proper use of mapping   */;
	#nop /*                   auto locate features                            */;
	#nop /*                                                                   */;
	#nop /*                                                                   */;
	#nop /* variables set by class                                            */;
	#nop /*      {caller} used to determine if condition caller is active     */;
	#nop /*                                                                   */;
	#nop /*      {class} used to store the current loaded character class     */;
	#nop /*                                                                   */;
	#nop /*      {classcheck} used to determine if a score command should be  */;
	#nop /*                   sent to the mud so the current class can be     */;
	#nop /*                   auto grabbed                                    */;
	#nop /*                                                                   */;
	#nop /*      {encond} used by stat tracker to store the last enemy        */;
	#nop /*               condition                                           */;
	#nop /*                                                                   */;
	#nop /*      {enemy} used to track the currently engaged enemy's name     */;
	#nop /*              when in battle                                       */;
	#nop /*                                                                   */;
	#nop /*      {loot} used to determine status of auto looter               */;
	#nop /*                                                                   */;
	#nop /*      {mapname} name of the map file that is loaded, or blank.  it */;
	#nop /*                is initiated here to allow testing it's value in   */;
	#nop /*                general.tt                                         */;
	#nop /*                                                                   */;
	#nop /*      {speechon} used to determine if the speech routine has been  */;
	#nop /*                 called yet                                        */
}
{1}

#ACTION {%* briefly reveals a red aura}
{
	gsay %1 is cursed!;
	#showme ::reshowforspeech::$me says %1 is cursed!
}
{5}

#ACTION {%* seems to be blinded!}
{
	#nop gsay %1 is blind!;
	#showme $me says %1 is blind!
}
{5}

#ACTION {%* suddenly looks speechless!}
{
	gsay %1 is being weally weally quite (silenced);
	#showme $me says %1 is silenced;
	#class silence kill
}
{5}

#ACTION {%w has just given you %w consent.}
{
	group %1 Let's go get ded!
}
{5}

#ACTION {You have learned something new about %*!}
{
	gsay %1 up!;
	#showme {you say %1 up!}
}
{5}

#ACTION {^Type the # or name of a character above to login or choose an action below.}
{
	#class rogue kill;
	#class cleric kill;
	#class psionicist kill;
	#class warrior kill;
	#variable {classcheck} {1};
	load classset;
	#if {$mapping}
	{
		load mapport
	}
}
{5}

#ACTION {^You raise a level!$}
{
	gsay Level UP!;
	#showme {You say Level UP}
}
{5}

#ACTION {^You receive %* XP (%*) experience.}
{
	#if {&loot}
	{
		#if {$loot}
		{
			loot
		}
	}
}
{5}

#ACTION {{< (\d{1,4})h/(\d{1,4})H(?: \d{1,3}p/\d{1,3}P)? (\d{1,4})v/(\d{1,4})V (.*)>}}
{
	#variable {pextra} {%6};
	#variable enemy {};
	#if {&etarg}
	{
		#class etarg kill
	};
	#regexp {$pextra} {{E:\s*(\w*)}} {#variable {enemy} {&2};};
	#if {"$enemy" != "" && $caller}
	{
		#regexp {$pextra} {{EC: ((?:nasty wounds)|(?:pretty hurt)|(?:awful)) (?:EP:)}} {#if {"&2" != "$encond"}{#var encond {&2};gsay $enemy is at $encond;};}
	};
	#else
	{
		#unvariable {encond}
	};
	#if {$groupcheck}
	{
		#class groupcheck kill;
		#unvariable stattarg;
		statfix
	};
	#if {$stateffects}
	{
		#class kill stateffects
	};
	#class glistadd kill;
	#if {$classcheck}
	{
		#variable classcheck 0;
		score
	};
	#unvariable pextra
}
{5}

#ACTION {~%i{^((?:\x1B\[(?:;?\d{1,3})+(?:m|K))*\w+(?:\x1B\[(?:;?\d{1,3})+(?:m|K))* (?:(?:\x1B\[(?:;?\d{1,3})+(?:m|K))*\(H\)(?:\x1B\[(?:;?\d{1,3})+(?:m|K))* )?(?:\x1B\[(?:;?\d{1,3})+(?:m|K))*(?:says?|tells?|group-says?|OOC|GCC|NHC|LFG|shouts?|(?:(?:group-)?projects? ')|(?:responds to your petition)|(?:responds to your group)).*)}}
{
	#format timestamp {%t} {{%H:%M:%S}};
	#line log chatlog.txt {%0 :: $timestamp};
	#unvariable timestamp;
	#variable {saytxt} {%1};
	#replace {saytxt} {{\x1B.*?[m|K]}}{};
	#replace {saytxt}{'}{};
	#replace {saytxt}{"}{};
	#if {$speechon}
	{
		#nop
	};
	#else
	{
		#variable {speechon}{1};
		#run speech espeak;
		#speech #kill;
		#session -
	};
	#regexp {$saytxt} {%i{(katumi tells.*|notice: the lfg ch)}} {#NOP;};
	#else
	{
		#speech {$saytxt}
	};
	#if {&statuses}
	{
		#variable statorlist {};
		#foreach {$tracked} {i}
		{
			#if {"$statorlist" != ""}
			{
				#variable statorlist {$statorlist|$i}
			};
			#else
			{
				#variable statorlist {$i}
			}
		};
		#foreach {$stats} {thisstat}
		{
			#regexp {$saytxt} {%i{^($statuses) .*(?:$statreg[$thisstat]).*?(?:out|off|expired|down|faded|bu-bye!)}} {statset @btarg{&2} $thisstat out;statfix;}
		};
		#unvariable thisstat
	};
	#unvariable {saytxt};
	#unvariable statorlist
}
{5}

#ALIAS {astat %1}
{
	tell katumi astat %1
}
{5}

#ALIAS {statcall %w}
{
	#switch {"%1"}
	{
		#case {"on"}
		{
			#variable {caller} {1}
		};
		#case {"off"}
		{
			#variable {caller} {0}
		}
	}
}
{5}

#ALIAS {killclass %w}
{
	#class %1 kill
}
{5}

#ALIAS {load %w}
{
	#read %1.tt
}
{5}

#ALIAS {loadmap}
{
	#if {"$mapname" != ""}
	{
		#map write $mapname;
		killclass mapping;
		killclass mapport;
		killclass mapmistake;
		killclass trans;
		#map destroy
	};
	#class mapkil open;
	#class mapkil write mapdisp.txt;
	#class mapkil kill;
	load mapping;
	#variable mapname %1;
	#map read $mapname;
	load mapport;
	load mapmistake
}
{5}

#ALIAS {logon %w}
{
	#session %1 50.57.109.188 9999
}
{5}

#ALIAS {oepn}
{
	open
}
{5}

#ALIAS {opne}
{
	open
}
{5}

#ALIAS {resetclass %w}
{
	#class %1 kill;
	load %1
}
{5}

#ALIAS {saveclass %w}
{
	#class %1 write %1.tt
}
{5}

#ALIAS {setme %w}
{
	#format {me} {%l} {%1}
}
{5}

#ALIAS {speechoff}
{
	#speech #zap;
	#unvariable speechon
}
{5}

#ALIAS {stat %1}
{
	tell katumi stat %1
}
{5}

#ALIAS {tloot}
{
	#switch {"%1"}
	{
		#case {"off"}
		{
			#variable loot 0;
			tloot
		};
		#case {"on"}
		{
			#variable loot 1;
			tloot
		};
		#case {"group"}
		{
			#variable loot 2;
			tloot
		};
		#default
		{
			#switch {$loot}
			{
				#case {1}
				{
					say loot is on
				};
				#case {2}
				{
					say loot is for group (and thats good enough for me)
				};
				#default
				{
					say loot is off
				}
			}
		}
	}
}
{5}

#ALIAS {{loot(?: (.*))?}}
{
	#variable {ltarg} {corpse};
	#showme %2;
	#regexp {%2} {{([0-9]+)}} {#var ltarg &1.corpse};
	#regexp {%2} {%i{([0-9]*[a-zA-Z\.]+)}} {#var ltarg &1};
	#if {$loot == 2}
	{
		gget all $ltarg
	};
	#else
	{
		get all $ltarg
	};
	#unvariable ltarg
}
{5}

#EVENT {PROGRAM START}
{
	#split
}

#EVENT {SESSION CONNECTED}
{
	load combat;
	load spellout;
	load statwin
}

#FUNCTION {btarg}
{
	#if {"%1" != ""}
	{
		#format {btname} {%l} {%1};
		#regexp {"$btname"} {{[1-9]}} {#IF {&t[%1]}{#RETURN $t[%1]};#ELSE {#VAR {result} {self}}};
		#else
		{
			#if {"$btname" == "me"}
			{
				#variable {result} {self}
			};
			#else
			{
				#variable {result} {$btname}
			}
		};
		#unvariable btname
	};
	#else
	{
		#if {&t[1]}
		{
			#variable {result} {$t[1]}
		};
		#else
		{
			#variable {result} {$me}
		}
	}
}

#MACRO {\eOk}
{
	d
}

#MACRO {\eOm}
{
	u
}

#MACRO {\eOr}
{
	s
}

#MACRO {\eOt}
{
	w
}

#MACRO {\eOu}
{
	l
}

#MACRO {\eOv}
{
	e
}

#MACRO {\eOx}
{
	n
}

#TAB              {@delkor}
#TAB              {@gormal}
#TAB              {@iamtux}
#TAB              {@lilithelle}
#TAB              {@lilmeshay}
#TAB              {bukot}
#TAB              {lilabipple}
#TAB              {lilebeple}
#TAB              {lilithelle}
#TAB              {mixxillezissiy}
#TAB              {nilebbeple}
#TAB              {zenpegeble}
#VARIABLE         {caller}  {0}
#VARIABLE         {class}  {}
#VARIABLE         {classcheck}  {0}
#VARIABLE         {enemy}  {}
#VARIABLE         {loot}  {0}
#VARIABLE         {mapname}  {}
#VARIABLE         {speechon}  {0}

#CLASS {general} CLOSE
